"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var errors_exports = {};
__export(errors_exports, {
  BadRequestError: () => BadRequestError,
  ConflictError: () => ConflictError,
  DataExportError: () => DataExportError,
  DataImportError: () => DataImportError,
  DisabledFeatureError: () => DisabledFeatureError,
  EmailError: () => EmailError,
  HelperWarning: () => HelperWarning,
  HostLimitError: () => HostLimitError,
  IncorrectUsageError: () => IncorrectUsageError,
  InternalServerError: () => InternalServerError,
  MaintenanceError: () => MaintenanceError,
  MethodNotAllowedError: () => MethodNotAllowedError,
  MigrationError: () => MigrationError,
  NoContentError: () => NoContentError,
  NoPermissionError: () => NoPermissionError,
  NotFoundError: () => NotFoundError,
  PasswordResetRequiredError: () => PasswordResetRequiredError,
  RangeNotSatisfiableError: () => RangeNotSatisfiableError,
  RequestEntityTooLargeError: () => RequestEntityTooLargeError,
  RequestNotAcceptableError: () => RequestNotAcceptableError,
  ThemeValidationError: () => ThemeValidationError,
  TokenRevocationError: () => TokenRevocationError,
  TooManyRequestsError: () => TooManyRequestsError,
  UnauthorizedError: () => UnauthorizedError,
  UnhandledJobError: () => UnhandledJobError,
  UnsupportedMediaTypeError: () => UnsupportedMediaTypeError,
  UpdateCollisionError: () => UpdateCollisionError,
  ValidationError: () => ValidationError,
  VersionMismatchError: () => VersionMismatchError
});
module.exports = __toCommonJS(errors_exports);
var import_GhostError = require("./GhostError");
const mergeOptions = (options, defaults) => {
  const result = { ...defaults };
  Object.keys(options).forEach((key) => {
    if (options[key] !== void 0) {
      result[key] = options[key];
    }
  });
  return result;
};
class InternalServerError extends import_GhostError.GhostError {
  constructor(options = {}) {
    super(mergeOptions(options, {
      statusCode: 500,
      level: "critical",
      errorType: "InternalServerError",
      message: "The server has encountered an error."
    }));
  }
}
class IncorrectUsageError extends import_GhostError.GhostError {
  constructor(options = {}) {
    super(mergeOptions(options, {
      statusCode: 400,
      level: "critical",
      errorType: "IncorrectUsageError",
      message: "We detected a misuse. Please read the stack trace."
    }));
  }
}
class NotFoundError extends import_GhostError.GhostError {
  constructor(options = {}) {
    super(mergeOptions(options, {
      statusCode: 404,
      errorType: "NotFoundError",
      message: "Resource could not be found.",
      hideStack: true
    }));
  }
}
class BadRequestError extends import_GhostError.GhostError {
  constructor(options = {}) {
    super(mergeOptions(options, {
      statusCode: 400,
      errorType: "BadRequestError",
      message: "The request could not be understood."
    }));
  }
}
class UnauthorizedError extends import_GhostError.GhostError {
  constructor(options = {}) {
    super(mergeOptions(options, {
      statusCode: 401,
      errorType: "UnauthorizedError",
      message: "You are not authorised to make this request."
    }));
  }
}
class NoPermissionError extends import_GhostError.GhostError {
  constructor(options = {}) {
    super(mergeOptions(options, {
      statusCode: 403,
      errorType: "NoPermissionError",
      message: "You do not have permission to perform this request."
    }));
  }
}
class ValidationError extends import_GhostError.GhostError {
  constructor(options = {}) {
    super(mergeOptions(options, {
      statusCode: 422,
      errorType: "ValidationError",
      message: "The request failed validation."
    }));
  }
}
class UnsupportedMediaTypeError extends import_GhostError.GhostError {
  constructor(options = {}) {
    super(mergeOptions(options, {
      statusCode: 415,
      errorType: "UnsupportedMediaTypeError",
      message: "The media in the request is not supported by the server."
    }));
  }
}
class TooManyRequestsError extends import_GhostError.GhostError {
  constructor(options = {}) {
    super(mergeOptions(options, {
      statusCode: 429,
      errorType: "TooManyRequestsError",
      message: "Server has received too many similar requests in a short space of time."
    }));
  }
}
class MaintenanceError extends import_GhostError.GhostError {
  constructor(options = {}) {
    super(mergeOptions(options, {
      statusCode: 503,
      errorType: "MaintenanceError",
      message: "The server is temporarily down for maintenance."
    }));
  }
}
class MethodNotAllowedError extends import_GhostError.GhostError {
  constructor(options = {}) {
    super(mergeOptions(options, {
      statusCode: 405,
      errorType: "MethodNotAllowedError",
      message: "Method not allowed for resource."
    }));
  }
}
class RequestNotAcceptableError extends import_GhostError.GhostError {
  constructor(options = {}) {
    super(mergeOptions(options, {
      statusCode: 406,
      errorType: "RequestNotAcceptableError",
      message: "Request not acceptable for provided Accept-Version header.",
      hideStack: true
    }));
  }
}
class RangeNotSatisfiableError extends import_GhostError.GhostError {
  constructor(options = {}) {
    super(mergeOptions(options, {
      statusCode: 416,
      errorType: "RangeNotSatisfiableError",
      message: "Range not satisfiable for provided Range header.",
      hideStack: true
    }));
  }
}
class RequestEntityTooLargeError extends import_GhostError.GhostError {
  constructor(options = {}) {
    super(mergeOptions(options, {
      statusCode: 413,
      errorType: "RequestEntityTooLargeError",
      message: "Request was too big for the server to handle."
    }));
  }
}
class TokenRevocationError extends import_GhostError.GhostError {
  constructor(options = {}) {
    super(mergeOptions(options, {
      statusCode: 503,
      errorType: "TokenRevocationError",
      message: "Token is no longer available."
    }));
  }
}
class VersionMismatchError extends import_GhostError.GhostError {
  constructor(options = {}) {
    super(mergeOptions(options, {
      statusCode: 400,
      errorType: "VersionMismatchError",
      message: "Requested version does not match server version."
    }));
  }
}
class DataExportError extends import_GhostError.GhostError {
  constructor(options = {}) {
    super(mergeOptions(options, {
      statusCode: 500,
      errorType: "DataExportError",
      message: "The server encountered an error whilst exporting data."
    }));
  }
}
class DataImportError extends import_GhostError.GhostError {
  constructor(options = {}) {
    super(mergeOptions(options, {
      statusCode: 500,
      errorType: "DataImportError",
      message: "The server encountered an error whilst importing data."
    }));
  }
}
class EmailError extends import_GhostError.GhostError {
  constructor(options = {}) {
    super(mergeOptions(options, {
      statusCode: 500,
      errorType: "EmailError",
      message: "The server encountered an error whilst sending email."
    }));
  }
}
class ThemeValidationError extends import_GhostError.GhostError {
  constructor(options = {}) {
    super(mergeOptions(options, {
      statusCode: 422,
      errorType: "ThemeValidationError",
      message: "The theme has a validation error.",
      errorDetails: {}
    }));
  }
}
class DisabledFeatureError extends import_GhostError.GhostError {
  constructor(options = {}) {
    super(mergeOptions(options, {
      statusCode: 409,
      errorType: "DisabledFeatureError",
      message: "Unable to complete the request, this feature is disabled."
    }));
  }
}
class UpdateCollisionError extends import_GhostError.GhostError {
  constructor(options = {}) {
    super(mergeOptions(options, {
      statusCode: 409,
      errorType: "UpdateCollisionError",
      message: "Unable to complete the request, there was a conflict."
    }));
  }
}
class HostLimitError extends import_GhostError.GhostError {
  constructor(options = {}) {
    super(mergeOptions(options, {
      errorType: "HostLimitError",
      hideStack: true,
      statusCode: 403,
      message: "Unable to complete the request, this resource is limited."
    }));
  }
}
class HelperWarning extends import_GhostError.GhostError {
  constructor(options = {}) {
    super(mergeOptions(options, {
      errorType: "HelperWarning",
      hideStack: true,
      statusCode: 400,
      message: "A theme helper has done something unexpected."
    }));
  }
}
class PasswordResetRequiredError extends import_GhostError.GhostError {
  constructor(options = {}) {
    super(mergeOptions(options, {
      errorType: "PasswordResetRequiredError",
      statusCode: 401,
      message: "For security, you need to create a new password. An email has been sent to you with instructions!"
    }));
  }
}
class UnhandledJobError extends import_GhostError.GhostError {
  constructor(options = {}) {
    super(mergeOptions(options, {
      errorType: "UnhandledJobError",
      message: "Processed job threw an unhandled error",
      level: "critical"
    }));
  }
}
class NoContentError extends import_GhostError.GhostError {
  constructor(options = {}) {
    super(mergeOptions(options, {
      errorType: "NoContentError",
      statusCode: 204,
      hideStack: true
    }));
  }
}
class ConflictError extends import_GhostError.GhostError {
  constructor(options = {}) {
    super(mergeOptions(options, {
      errorType: "ConflictError",
      statusCode: 409,
      message: "The server has encountered an conflict."
    }));
  }
}
class MigrationError extends import_GhostError.GhostError {
  constructor(options = {}) {
    super(mergeOptions(options, {
      errorType: "MigrationError",
      message: "An error has occurred applying a database migration.",
      level: "critical"
    }));
  }
}
